import{l as w}from"./Color-af6e0c66.js";import{U as S}from"./request-f17a8ddb.js";import{s as M,a as L}from"./Error-57322e92.js";import{e as R}from"./LRUCache-b9228ca3.js";import{r as d,t as I}from"./typedArrayUtil-d9bc5fbd.js";import{j as $}from"./promiseUtils-32d9c228.js";import{c as v}from"./string-480f3e3f.js";import{i as N,u as T}from"./arcadeOnDemand-5175e7d9.js";import{d as j}from"./CIMSymbol-8f02a6e3.js";import"./colorUtils-639f4d25.js";import"./mathUtils-57aba1ea.js";import"./vec3-1863987c.js";import"./vec3f64-6cd30318.js";import"./common-c186b691.js";import"./vec4-46a9b36d.js";import"./ensureType-25b8cc06.js";import"./preload-helper-101896b7.js";import"./MemCache-1d2f56ee.js";import"./cast-a534ae90.js";import"./nextTick-3ee5a785.js";import"./geometry-eec1b371.js";import"./Extent-a1a1de42.js";import"./Polyline-b571c705.js";import"./typeUtils-cd52dc20.js";import"./jsonMap-190c5593.js";import"./enumeration-61a13175.js";import"./fieldUtils-77ec75e2.js";import"./Symbol-8266348e.js";const P="esri.renderers.support.DictionaryLoader",q={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class mt{constructor(t,e,o){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new R(100),this._dictionaryPromise=null,this.url=t,this.config=e,this.fieldMap=o}getSymbolFields(){return this._symbolFields}async getSymbolAsync(t,e){let o;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(e));try{o=await this._dictionaryPromise}catch(n){if($(n))return this._dictionaryPromise=null,null}const i={};if(this.fieldMap)for(const n of this._symbolFields){const m=this.fieldMap[n];if(m&&t.attributes[m]!=null){const b=""+t.attributes[m];i[n]=b}else i[n]=""}const r=o==null?void 0:o(i,e);if(!r||typeof r!="string")return null;const l=v(r).toString(),f=this._symbolCache.get(l);if(f)return f.catch(()=>{this._symbolCache.pop(l)}),f;const a=r.split(";"),s=[],c=[];for(const n of a)if(n)if(n.includes("po:")){const m=n.substr(3).split("|");if(m.length===3){const b=m[0],_=m[1];let h=m[2];if(_==="DashTemplate")h=h.split(" ").map(u=>Number(u));else if(_==="Color"){const u=new w(h).toRgba();h=[u[0],u[1],u[2],255*u[3]]}else h=Number(h);c.push({primitiveName:b,propertyName:_,value:h})}}else if(n.includes("|")){for(const m of n.split("|"))if(this._itemNames.has(m)){s.push(m);break}}else this._itemNames.has(n)&&s.push(n);const y=!d(t.geometry)||!t.geometry.hasZ&&t.geometry.type==="point",p=this._cimPartsToCIMSymbol(s,c,y,e);return this._symbolCache.put(l,p,1),p}async fetchResources(t){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void M.getLogger(P).error("no valid URL!");const e=S(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:d(t)?t.signal:null}),[{data:o}]=await Promise.all([e,N()]);if(!o)throw this._dictionaryPromise=null,new L("esri.renderers.DictionaryRenderer","Bad dictionary data!");const i=o.expression,r=o.authoringInfo;this._refSymbolUrlTemplate=this.url+"/"+o.cimRefTemplateUrl,this._itemNames=new Set(o.itemsNames),this._symbolFields=r.symbol;const l={};if(this.config){const s=this.config;for(const c in s)l[c]=s[c]}if(r.configuration)for(const s of r.configuration)l.hasOwnProperty(s.name)||(l[s.name]=s.value);const f=[];if(d(t)&&t.fields&&this.fieldMap)for(const s of this._symbolFields){const c=this.fieldMap[s],y=t.fields.filter(p=>p.name===c);y.length>0&&f.push({...y[0],name:s})}const a=T(i,d(t)?t.spatialReference:null,f,l).then(s=>{const c={scale:0};return(y,p)=>{if(I(s))return null;const n=s.repurposeFeature({geometry:null,attributes:y});return c.scale=d(p)?p.scale:void 0,s.evaluate({$feature:n,$view:c})}}).catch(s=>(M.getLogger(P).error("Creating dictinoary expression failed:",s),null));return this._dictionaryPromise=a,a}async _cimPartsToCIMSymbol(t,e,o,i){const r=new Array(t.length);for(let a=0;a<t.length;a++)r[a]=this._getSymbolPart(t[a],i);const l=await Promise.all(r),f=this.fieldMap;if(f)for(const a of l)C(a,f);return new j({data:this._combineSymbolParts(l,e,o)})}async _getSymbolPart(t,e){if(this._ongoingRequests.has(t))return this._ongoingRequests.get(t).then(r=>r.data);const o=this._refSymbolUrlTemplate.replace(/\{itemName\}/gi,t),i=S(o,{responseType:"json",query:{f:"json"},...e});this._ongoingRequests.set(t,i);try{return(await i).data}catch(r){throw this._ongoingRequests.delete(t),r}}_combineSymbolParts(t,e,o){if(!t||t.length===0)return null;const i={...t[0]};if(t.length>1){i.symbolLayers=[];for(const r of t){const l=r;i.symbolLayers.unshift(...l.symbolLayers)}}return o&&(i.callout=q),{type:"CIMSymbolReference",symbol:i,primitiveOverrides:e}}}function C(g,t){if(!g)return;const e=g.symbolLayers;if(!e)return;let o=e.length;for(;o--;){const i=e[o];i&&i.enable!==!1&&i.type==="CIMVectorMarker"&&F(i,t)}}function F(g,t){const e=g.markerGraphics;if(e)for(const o of e){if(!o)continue;const i=o.symbol;if(i)switch(i.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":C(i,t);break;case"CIMTextSymbol":i.fieldMap=t}}}export{mt as DictionaryLoader};
