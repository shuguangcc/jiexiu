import{t as C,r as d,T as O}from"./typedArrayUtil-d9bc5fbd.js";import{S as k}from"./quat-ec16a584.js";import{g as $,f as D,c as F,I as R,e as U}from"./I3SBinaryReader-1bc9f090.js";import{E as z}from"./vec3-1863987c.js";import{r as B,n as A}from"./vec3f32-4322908d.js";import{x as J}from"./projection-0af97a56.js";import{k as S}from"./Extent-a1a1de42.js";import{a as N,b as T,d as V}from"./PointCloudUniqueValueRenderer-cdf427ed.js";import"./quatf64-c94bd656.js";import"./vec3f64-6cd30318.js";import"./common-c186b691.js";import"./vec4-46a9b36d.js";import"./Error-57322e92.js";import"./string-480f3e3f.js";import"./VertexAttribute-9c5c630d.js";import"./preload-helper-101896b7.js";import"./mathUtils-57aba1ea.js";import"./promiseUtils-32d9c228.js";import"./unitUtils-dd6fb8ee.js";import"./jsonMap-190c5593.js";import"./cast-a534ae90.js";import"./ensureType-25b8cc06.js";import"./nextTick-3ee5a785.js";import"./SimpleObservable-8e532943.js";import"./mat4-7dde83b1.js";import"./Polyline-b571c705.js";import"./assets-a5ce5e1a.js";import"./request-f17a8ddb.js";import"./aaBoundingRect-b340cf8c.js";import"./zscale-48bab05e.js";import"./enumeration-61a13175.js";import"./LegendOptions-2e7b3d70.js";import"./Color-af6e0c66.js";import"./colorUtils-639f4d25.js";function _(f,t,l,o){const{rendererJSON:u,isRGBRenderer:m}=f;let n=null,i=null;if(t&&m)n=t;else if(t&&u.type==="pointCloudUniqueValueRenderer"){i=N.fromJSON(u);const r=i.colorUniqueValueInfos;n=new Uint8Array(3*o);const s=v(i.fieldTransformType);for(let e=0;e<o;e++){const c=(s?s(t[e]):t[e])+"";for(let a=0;a<r.length;a++)if(r[a].values.includes(c)){n[3*e]=r[a].color.r,n[3*e+1]=r[a].color.g,n[3*e+2]=r[a].color.b;break}}}else if(t&&u.type==="pointCloudStretchRenderer"){i=T.fromJSON(u);const r=i.stops;n=new Uint8Array(3*o);const s=v(i.fieldTransformType);for(let e=0;e<o;e++){const c=s?s(t[e]):t[e],a=r.length-1;if(c<r[0].value)n[3*e]=r[0].color.r,n[3*e+1]=r[0].color.g,n[3*e+2]=r[0].color.b;else if(c>=r[a].value)n[3*e]=r[a].color.r,n[3*e+1]=r[a].color.g,n[3*e+2]=r[a].color.b;else for(let p=1;p<r.length;p++)if(c<r[p].value){const b=(c-r[p-1].value)/(r[p].value-r[p-1].value);n[3*e]=r[p].color.r*b+r[p-1].color.r*(1-b),n[3*e+1]=r[p].color.g*b+r[p-1].color.g*(1-b),n[3*e+2]=r[p].color.b*b+r[p-1].color.b*(1-b);break}}}else if(t&&u.type==="pointCloudClassBreaksRenderer"){i=V.fromJSON(u);const r=i.colorClassBreakInfos;n=new Uint8Array(3*o);const s=v(i.fieldTransformType);for(let e=0;e<o;e++){const c=s?s(t[e]):t[e];for(let a=0;a<r.length;a++)if(c>=r[a].minValue&&c<=r[a].maxValue){n[3*e]=r[a].color.r,n[3*e+1]=r[a].color.g,n[3*e+2]=r[a].color.b;break}}}else{n=new Uint8Array(3*o);for(let r=0;r<n.length;r++)n[r]=255}if(l&&i&&i.colorModulation){const r=i.colorModulation.minValue,s=i.colorModulation.maxValue,e=.3;for(let c=0;c<o;c++){const a=l[c],p=a>=s?1:a<=r?e:e+(1-e)*(a-r)/(s-r);n[3*c]=p*n[3*c],n[3*c+1]=p*n[3*c+1],n[3*c+2]=p*n[3*c+2]}}return n}function q(f,t){if(f.encoding==null||f.encoding===""){const l=$(t,f);if(C(l.vertexAttributes.position))return;const o=D(t,l.vertexAttributes.position),u=l.header.fields,m=[u.offsetX,u.offsetY,u.offsetZ],n=[u.scaleX,u.scaleY,u.scaleZ],i=o.length/3,r=new Float64Array(3*i);for(let s=0;s<i;s++)r[3*s]=o[3*s]*n[0]+m[0],r[3*s+1]=o[3*s+1]*n[1]+m[1],r[3*s+2]=o[3*s+2]*n[2]+m[2];return r}if(f.encoding==="lepcc-xyz")return F(t).result}function g(f,t,l){return d(f)&&f.attributeInfo.useElevation?E(t,l):d(f)?R(f.attributeInfo.storageInfo,f.buffer,l):null}function E(f,t){const l=new Float64Array(t);for(let o=0;o<t;o++)l[o]=f[3*o+2];return l}function P(f,t,l,o,u){const m=f.length/3;let n=0;for(let i=0;i<m;i++){let r=!0;for(let s=0;s<o.length&&r;s++){const{filterJSON:e}=o[s],c=u[s].values[i];switch(e.type){case"pointCloudValueFilter":{const a=e.mode==="exclude";e.values.includes(c)===a&&(r=!1);break}case"pointCloudBitfieldFilter":{const a=M(e.requiredSetBits),p=M(e.requiredClearBits);(c&a)===a&&!(c&p)||(r=!1);break}case"pointCloudReturnFilter":{const a=15&c,p=c>>>4&15,b=p>1,x=a===1,y=a===p;let I=!1;for(const h of e.includedReturns)if(h==="last"&&y||h==="firstOfMany"&&x&&b||h==="lastOfMany"&&y&&b||h==="single"&&!b){I=!0;break}I||(r=!1);break}}}r&&(l[n]=i,f[3*n]=f[3*i],f[3*n+1]=f[3*i+1],f[3*n+2]=f[3*i+2],t[3*n]=t[3*i],t[3*n+1]=t[3*i+1],t[3*n+2]=t[3*i+2],n++)}return n}function v(f){return f==null||f==="none"?null:f==="low-four-bit"?t=>15&t:f==="high-four-bit"?t=>(240&t)>>4:f==="absolute-value"?t=>Math.abs(t):f==="modulo-ten"?t=>t%10:null}function M(f){let t=0;for(const l of f||[])t|=1<<l;return t}class X{transform(t){const l=this._transform(t),o=[l.points.buffer,l.rgb.buffer];d(l.pointIdFilterMap)&&o.push(l.pointIdFilterMap.buffer);for(const u of l.attributes)"buffer"in u.values&&O(u.values.buffer)&&u.values.buffer!==l.rgb.buffer&&o.push(u.values.buffer);return Promise.resolve({result:l,transferList:o})}_transform(t){const l=q(t.schema,t.geometryBuffer);let o=l.length/3,u=null;const m=[],n=g(t.primaryAttributeData,l,o);d(t.primaryAttributeData)&&n&&m.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:n});const i=g(t.modulationAttributeData,l,o);d(t.modulationAttributeData)&&i&&m.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:i});let r=_(t.rendererInfo,n,i,o);if(t.filterInfo&&t.filterInfo.length>0&&d(t.filterAttributesData)){const e=t.filterAttributesData.map(c=>{const a=g(c,l,o),p={attributeInfo:c.attributeInfo,values:a};return m.push(p),p});u=new Uint32Array(o),o=P(l,r,u,t.filterInfo,e)}for(const e of t.userAttributesData){const c=g(e,l,o);m.push({attributeInfo:e.attributeInfo,values:c})}3*o<r.length&&(r=new Uint8Array(r.buffer.slice(0,3*o))),this._applyElevationOffsetInPlace(l,o,t.elevationOffset);const s=this._transformCoordinates(l,o,t.obb,S.fromJSON(t.inSR),S.fromJSON(t.outSR));return{obb:t.obb,points:s,rgb:r,attributes:m,pointIdFilterMap:u}}_transformCoordinates(t,l,o,u,m){if(!J(t,u,0,t,m,0,l))throw new Error("Can't reproject");const n=B(o.center[0],o.center[1],o.center[2]),i=A(),r=A();k(w,o.quaternion);const s=new Float32Array(3*l);for(let e=0;e<l;e++)i[0]=t[3*e]-n[0],i[1]=t[3*e+1]-n[1],i[2]=t[3*e+2]-n[2],z(r,i,w),o.halfSize[0]=Math.max(o.halfSize[0],Math.abs(r[0])),o.halfSize[1]=Math.max(o.halfSize[1],Math.abs(r[1])),o.halfSize[2]=Math.max(o.halfSize[2],Math.abs(r[2])),s[3*e]=i[0],s[3*e+1]=i[1],s[3*e+2]=i[2];return s}_applyElevationOffsetInPlace(t,l,o){if(o!==0)for(let u=0;u<l;u++)t[3*u+2]+=o}}const w=U();function xt(){return new X}export{xt as default};
