const $={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,safari10:!1,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,cssVarShim:!1,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,dynamicImportShim:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!1,asyncQueue:!1,transformTagName:!1,attachStyles:!0};let v,te,I,se=!1,w=!1,M=!1,g=!1,N=null,F=!1;const mt={isDev:!!$.isDev,isBrowser:!0,isServer:!1,isTesting:!!$.isTesting},St=e=>{const t=new URL(e,h.$resourcesUrl$);return t.origin!==L.location.origin?t.href:t.pathname},vt=e=>h.$resourcesUrl$=e,S=(e,t="")=>()=>{},W="http://www.w3.org/1999/xlink",z={},be="http://www.w3.org/2000/svg",Te="http://www.w3.org/1999/xhtml",Le=e=>e!=null,_=e=>(e=typeof e,e==="object"||e==="function"),ne=(e,t,...s)=>{let n=null,o=null,l=null,r=!1,i=!1;const c=[],a=u=>{for(let d=0;d<u.length;d++)n=u[d],Array.isArray(n)?a(n):n!=null&&typeof n!="boolean"&&((r=typeof e!="function"&&!_(n))&&(n=String(n)),r&&i?c[c.length-1].$text$+=n:c.push(r?C(null,n):n),i=r)};if(a(s),t&&($.isDev&&e==="input"&&Ae(t),$.vdomKey&&t.key&&(o=t.key),$.slotRelocation&&t.name&&(l=t.name),$.vdomClass)){const u=t.className||t.class;u&&(t.class=typeof u!="object"?u:Object.keys(u).filter(d=>u[d]).join(" "))}if($.isDev&&c.some(oe)&&st(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),$.vdomFunctional&&typeof e=="function")return e(t===null?{}:t,c,Ee);const f=C(e,null);return f.$attrs$=t,c.length>0&&(f.$children$=c),$.vdomKey&&(f.$key$=o),$.slotRelocation&&(f.$name$=l),f},C=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return $.vdomAttribute&&(s.$attrs$=null),$.vdomKey&&(s.$key$=null),$.slotRelocation&&(s.$name$=null),s},xe={},oe=e=>e&&e.$tag$===xe,Ee={forEach:(e,t)=>e.map(K).forEach(t),map:(e,t)=>e.map(K).map(t).map(Re)},K=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Re=e=>{if(typeof e.vtag=="function"){const s=Object.assign({},e.vattrs);return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),ne(e.vtag,s,...e.vchildren||[])}const t=C(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Ae=e=>{const t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;const n=t.indexOf("type"),o=t.indexOf("min"),l=t.indexOf("max"),r=t.indexOf("step");(s<n||s<o||s<l||s<r)&&pe('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},De=e=>nt.map(t=>t(e)).find(t=>!!t),Oe=(e,t)=>e!=null&&!_(e)?t&4?e==="false"?!1:e===""||!!e:t&2?parseFloat(e):t&1?String(e):e:e,we=e=>$.lazyLoad?T(e).$hostElement$:e,kt=(e,t,s)=>{const n=we(e);return{emit:o=>($.isDev&&!n.isConnected&&pe(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),Ce(n,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:o}))}},Ce=(e,t,s)=>{const n=h.ce(t,s);return e.dispatchEvent(n),n},Q=new WeakMap,Pe=(e,t,s)=>{let n=B.get(e);rt&&s?(n=n||new CSSStyleSheet,typeof n=="string"?n=t:n.replaceSync(t)):n=t,B.set(e,n)},Be=(e,t,s,n)=>{let o=le(t,s);const l=B.get(o);if(e=e.nodeType===11?e:m,l)if(typeof l=="string"){e=e.head||e;let r=Q.get(e),i;r||Q.set(e,r=new Set),r.has(o)||(i=m.createElement("style"),i.innerHTML=l,e.insertBefore(i,e.querySelector("link")),r&&r.add(o))}else e.adoptedStyleSheets.includes(l)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return o},Ue=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,o=S("attachStyles",t.$tagName$),l=Be(U&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);n&10&&(s["s-sc"]=l,s.classList.add(l+"-h"),n&2&&s.classList.add(l+"-s")),o()},le=(e,t)=>"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),X=(e,t,s,n,o,l)=>{if(s!==n){let r=Z(e,t),i=t.toLowerCase();if(t==="class"){const c=e.classList,a=Y(s),f=Y(n);c.remove(...a.filter(u=>u&&!f.includes(u))),c.add(...f.filter(u=>u&&!a.includes(u)))}else if(t==="style"){for(const c in s)(!n||n[c]==null)&&(c.includes("-")?e.style.removeProperty(c):e.style[c]="");for(const c in n)(!s||n[c]!==s[c])&&(c.includes("-")?e.style.setProperty(c,n[c]):e.style[c]=n[c])}else if(t!=="key")if(t==="ref")n&&n(e);else if(!e.__lookupSetter__(t)&&t[0]==="o"&&t[1]==="n")t[2]==="-"?t=t.slice(3):Z(L,i)?t=i.slice(2):t=i[2]+t.slice(3),s&&h.rel(e,t,s,!1),n&&h.ael(e,t,n,!1);else{const c=_(n);if((r||c&&n!==null)&&!o)try{if(e.tagName.includes("-"))e[t]=n;else{const f=n??"";t==="list"?r=!1:(s==null||e[t]!=f)&&(e[t]=f)}}catch{}let a=!1;i!==(i=i.replace(/^xlink\:?/,""))&&(t=i,a=!0),n==null||n===!1?(n!==!1||e.getAttribute(t)==="")&&(a?e.removeAttributeNS(W,t):e.removeAttribute(t)):(!r||l&4||o)&&!c&&(n=n===!0?"":n,a?e.setAttributeNS(W,t,n):e.setAttribute(t,n))}}},Ie=/\s/,Y=e=>e?e.split(Ie):[],re=(e,t,s,n)=>{const o=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||z,r=t.$attrs$||z;for(n in l)n in r||X(o,n,l[n],void 0,s,t.$flags$);for(n in r)X(o,n,l[n],r[n],s,t.$flags$)},P=(e,t,s,n)=>{const o=t.$children$[s];let l=0,r,i,c;if(se||(M=!0,o.$tag$==="slot"&&(v&&n.classList.add(v+"-s"),o.$flags$|=o.$children$?2:1)),o.$text$!==null)r=o.$elm$=m.createTextNode(o.$text$);else if(o.$flags$&1)r=o.$elm$=m.createTextNode("");else{if(g||(g=o.$tag$==="svg"),r=o.$elm$=m.createElementNS(g?be:Te,o.$flags$&2?"slot-fb":o.$tag$),g&&o.$tag$==="foreignObject"&&(g=!1),re(null,o,g),Le(v)&&r["s-si"]!==v&&r.classList.add(r["s-si"]=v),o.$children$)for(l=0;l<o.$children$.length;++l)i=P(e,o,l,r),i&&r.appendChild(i);o.$tag$==="svg"?g=!1:r.tagName==="foreignObject"&&(g=!0)}return r["s-hn"]=I,o.$flags$&3&&(r["s-sr"]=!0,r["s-cr"]=te,r["s-sn"]=o.$name$||"",c=e&&e.$children$&&e.$children$[s],c&&c.$tag$===o.$tag$&&e.$elm$&&E(e.$elm$,!1)),r},E=(e,t)=>{h.$flags$|=1;const s=e.childNodes;for(let n=s.length-1;n>=0;n--){const o=s[n];o["s-hn"]!==I&&o["s-ol"]&&(ae(o).insertBefore(o,H(o)),o["s-ol"].remove(),o["s-ol"]=void 0,M=!0),t&&E(o,t)}h.$flags$&=-2},ie=(e,t,s,n,o,l)=>{let r=e["s-cr"]&&e["s-cr"].parentNode||e,i;for(r.shadowRoot&&r.tagName===I&&(r=r.shadowRoot);o<=l;++o)n[o]&&(i=P(null,s,o,e),i&&(n[o].$elm$=i,r.insertBefore(i,H(t))))},ce=(e,t,s,n,o)=>{for(;t<=s;++t)(n=e[t])&&(o=n.$elm$,ue(n),w=!0,o["s-ol"]?o["s-ol"].remove():E(o,!0),o.remove())},Fe=(e,t,s,n)=>{let o=0,l=0,r=0,i=0,c=t.length-1,a=t[0],f=t[c],u=n.length-1,d=n[0],p=n[u],x,D;for(;o<=c&&l<=u;)if(a==null)a=t[++o];else if(f==null)f=t[--c];else if(d==null)d=n[++l];else if(p==null)p=n[--u];else if(O(a,d))k(a,d),a=t[++o],d=n[++l];else if(O(f,p))k(f,p),f=t[--c],p=n[--u];else if(O(a,p))(a.$tag$==="slot"||p.$tag$==="slot")&&E(a.$elm$.parentNode,!1),k(a,p),e.insertBefore(a.$elm$,f.$elm$.nextSibling),a=t[++o],p=n[--u];else if(O(f,d))(a.$tag$==="slot"||p.$tag$==="slot")&&E(f.$elm$.parentNode,!1),k(f,d),e.insertBefore(f.$elm$,a.$elm$),f=t[--c],d=n[++l];else{for(r=-1,i=o;i<=c;++i)if(t[i]&&t[i].$key$!==null&&t[i].$key$===d.$key$){r=i;break}r>=0?(D=t[r],D.$tag$!==d.$tag$?x=P(t&&t[l],s,r,e):(k(D,d),t[r]=void 0,x=D.$elm$),d=n[++l]):(x=P(t&&t[l],s,l,e),d=n[++l]),x&&ae(a.$elm$).insertBefore(x,H(a.$elm$))}o>c?ie(e,n[u+1]==null?null:n[u+1].$elm$,s,n,l,u):l>u&&ce(t,o,c)},O=(e,t)=>e.$tag$===t.$tag$?e.$tag$==="slot"?e.$name$===t.$name$:e.$key$===t.$key$:!1,H=e=>e&&e["s-ol"]||e,ae=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,k=(e,t)=>{const s=t.$elm$=e.$elm$,n=e.$children$,o=t.$children$,l=t.$tag$,r=t.$text$;let i;r===null?(g=l==="svg"?!0:l==="foreignObject"?!1:g,l==="slot"||re(e,t,g),n!==null&&o!==null?Fe(s,n,t,o):o!==null?(e.$text$!==null&&(s.textContent=""),ie(s,null,t,o,0,o.length-1)):n!==null&&ce(n,0,n.length-1),g&&l==="svg"&&(g=!1)):(i=s["s-cr"])?i.parentNode.textContent=r:e.$text$!==r&&(s.data=r)},$e=e=>{const t=e.childNodes;let s,n,o,l,r,i;for(n=0,o=t.length;n<o;n++)if(s=t[n],s.nodeType===1){if(s["s-sr"]){for(r=s["s-sn"],s.hidden=!1,l=0;l<o;l++)if(i=t[l].nodeType,t[l]["s-hn"]!==s["s-hn"]||r!==""){if(i===1&&r===t[l].getAttribute("slot")){s.hidden=!0;break}}else if(i===1||i===3&&t[l].textContent.trim()!==""){s.hidden=!0;break}}$e(s)}},y=[],fe=e=>{let t,s,n,o,l,r,i=0;const c=e.childNodes,a=c.length;for(;i<a;i++){if(t=c[i],t["s-sr"]&&(s=t["s-cr"])&&s.parentNode)for(n=s.parentNode.childNodes,o=t["s-sn"],r=n.length-1;r>=0;r--)s=n[r],!s["s-cn"]&&!s["s-nr"]&&s["s-hn"]!==t["s-hn"]&&(G(s,o)?(l=y.find(f=>f.$nodeToRelocate$===s),w=!0,s["s-sn"]=s["s-sn"]||o,l?l.$slotRefNode$=t:y.push({$slotRefNode$:t,$nodeToRelocate$:s}),s["s-sr"]&&y.map(f=>{G(f.$nodeToRelocate$,s["s-sn"])&&(l=y.find(u=>u.$nodeToRelocate$===s),l&&!f.$slotRefNode$&&(f.$slotRefNode$=l.$slotRefNode$))})):y.some(f=>f.$nodeToRelocate$===s)||y.push({$nodeToRelocate$:s}));t.nodeType===1&&fe(t)}},G=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",ue=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(ue)},je=(e,t)=>{const s=e.$hostElement$,n=e.$cmpMeta$,o=e.$vnode$||C(null,null),l=oe(t)?t:ne(null,null,t);I=s.tagName,n.$attrsToReflect$&&(l.$attrs$=l.$attrs$||{},n.$attrsToReflect$.map(([r,i])=>l.$attrs$[i]=s[r])),l.$tag$=null,l.$flags$|=4,e.$vnode$=l,l.$elm$=o.$elm$=s.shadowRoot||s,v=s["s-sc"],te=s["s-cr"],se=U&&(n.$flags$&1)!==0,w=!1,k(o,l);{if(h.$flags$|=1,M){fe(l.$elm$);let r,i,c,a,f,u,d=0;for(;d<y.length;d++)r=y[d],i=r.$nodeToRelocate$,i["s-ol"]||(c=m.createTextNode(""),c["s-nr"]=i,i.parentNode.insertBefore(i["s-ol"]=c,i));for(d=0;d<y.length;d++)if(r=y[d],i=r.$nodeToRelocate$,r.$slotRefNode$){for(a=r.$slotRefNode$.parentNode,f=r.$slotRefNode$.nextSibling,c=i["s-ol"];c=c.previousSibling;)if(u=c["s-nr"],u&&u["s-sn"]===i["s-sn"]&&a===u.parentNode&&(u=u.nextSibling,!u||!u["s-nr"])){f=u;break}(!f&&a!==i.parentNode||i.nextSibling!==f)&&i!==f&&(!i["s-hn"]&&i["s-ol"]&&(i["s-hn"]=i["s-ol"].parentNode.nodeName),a.insertBefore(i,f))}else i.nodeType===1&&(i.hidden=!0)}w&&$e(l.$elm$),h.$flags$&=-2,y.length=0}},Me=(e,t)=>{},q=(e,t)=>($.taskQueue&&$.updatable&&(e.$flags$|=16),Me(e,e.$ancestorComponent$),at(()=>_e(e,t))),_e=(e,t)=>{const s=e.$hostElement$,n=S("scheduleUpdate",e.$cmpMeta$.$tagName$),o=s;let l;return t?l=b(o,"componentWillLoad"):l=b(o,"componentWillUpdate"),l=J(l,()=>b(o,"componentWillRender")),n(),J(l,()=>He(e,o,t))},He=async(e,t,s)=>{const n=e.$hostElement$,o=S("update",e.$cmpMeta$.$tagName$);n["s-rc"],s&&Ue(e);const l=S("render",e.$cmpMeta$.$tagName$);qe(e,t,n),l(),o(),Ne(e)},qe=(e,t,s)=>{try{N=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,($.hasRenderFn||$.reflect)&&($.vdomRender||$.reflect)&&($.hydrateServerSide||je(e,t))}catch(i){A(i,e.$hostElement$)}return N=null,null},Ne=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,n=S("postUpdate",t),o=s;e.$ancestorComponent$,b(o,"componentDidRender"),e.$flags$&64?(b(o,"componentDidUpdate"),n()):(e.$flags$|=64,b(o,"componentDidLoad"),n())},bt=e=>{if($.updatable){const t=T(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&q(t,!1),s}return!1},b=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(n){A(n)}},J=(e,t)=>e&&e.then?e.then(t):t(),We=(e,t)=>T(e).$instanceValues$.get(t),ze=(e,t,s,n)=>{const o=T(e),l=e,r=o.$instanceValues$.get(t),i=o.$flags$,c=l;s=Oe(s,n.$members$[t][0]);const a=Number.isNaN(r)&&Number.isNaN(s);if(s!==r&&!a){o.$instanceValues$.set(t,s);{if(n.$watchers$&&i&128){const u=n.$watchers$[t];u&&u.map(d=>{try{c[d](s,r,t)}catch(p){A(p,l)}})}if((i&18)===2){if(c.componentShouldUpdate&&c.componentShouldUpdate(s,r,t)===!1)return;q(o,!1)}}}},Ke=(e,t,s)=>{if(t.$members$){e.watchers&&(t.$watchers$=e.watchers);const n=Object.entries(t.$members$),o=e.prototype;n.map(([l,[r]])=>{(r&31||r&32)&&Object.defineProperty(o,l,{get(){return We(this,l)},set(i){ze(this,l,i,t)},configurable:!0,enumerable:!0})});{const l=new Map;o.attributeChangedCallback=function(r,i,c){h.jmp(()=>{const a=l.get(r);if(this.hasOwnProperty(a))c=this[a],delete this[a];else if(o.hasOwnProperty(a)&&typeof this[a]=="number"&&this[a]==c)return;this[a]=c===null&&typeof this[a]=="boolean"?!1:c})},e.observedAttributes=n.filter(([r,i])=>i[0]&15).map(([r,i])=>{const c=i[1]||r;return l.set(c,r),i[0]&512&&t.$attrsToReflect$.push([r,c]),c})}}return e},Qe=async(e,t,s,n,o)=>{if(!(t.$flags$&32)&&(o=e.constructor,t.$flags$|=32,customElements.whenDefined(s.$tagName$).then(()=>t.$flags$|=128),o.style)){let r=o.style;typeof r!="string"&&(r=r[t.$modeName$=De(e)]);const i=le(s,t.$modeName$);if(!B.has(i)){const c=S("registerStyles",s.$tagName$);Pe(i,r,!!(s.$flags$&1)),c()}}t.$ancestorComponent$,(()=>q(t,!0))()},Xe=e=>{},Ye=e=>{if(!(h.$flags$&1)){const t=T(e),s=t.$cmpMeta$,n=S("connectedCallback",s.$tagName$);t.$flags$&1?(de(e,t,s.$listeners$),Xe(t.$lazyInstance$)):(t.$flags$|=1,s.$flags$&12&&Ge(e),s.$members$&&Object.entries(s.$members$).map(([o,[l]])=>{if(l&31&&e.hasOwnProperty(o)){const r=e[o];delete e[o],e[o]=r}}),Qe(e,t,s)),n()}},Ge=e=>{const t=e["s-cr"]=m.createComment("");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},Je=e=>{if(!(h.$flags$&1)){const t=T(e);t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0)}},Tt=(e,t)=>{const s={$flags$:t[0],$tagName$:t[1]};$.member&&(s.$members$=t[2]),$.hostListener&&(s.$listeners$=t[3]),$.watchCallback&&(s.$watchers$=e.$watchers$),$.reflect&&(s.$attrsToReflect$=[]),$.shadowDom&&!U&&s.$flags$&1&&(s.$flags$|=8);const n=e.prototype.connectedCallback,o=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){tt(this,s)},connectedCallback(){Ye(this),$.connectedCallback&&n&&n.call(this)},disconnectedCallback(){Je(this),$.disconnectedCallback&&o&&o.call(this)},__attachShadow(){U?$.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)}):this.attachShadow({mode:"open"}):this.shadowRoot=this}}),e.is=s.$tagName$,Ke(e,s)},Lt=(e,t)=>t,de=(e,t,s,n)=>{s&&s.map(([o,l,r])=>{const i=Ve(e,o),c=Ze(t,r),a=et(o);h.ael(i,l,c,a),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>h.rel(i,l,c,a))})},Ze=(e,t)=>s=>{try{$.lazyLoad||e.$hostElement$[t](s)}catch(n){A(n)}},Ve=(e,t)=>t&4?m:t&8?L:t&16?m.body:e,et=e=>ot?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0,he=new WeakMap,T=e=>he.get(e),tt=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return $.isDev&&(s.$renderCount$=0),$.method&&$.lazyLoad&&(s.$onInstancePromise$=new Promise(n=>s.$onInstanceResolve$=n)),$.asyncLoading&&(s.$onReadyPromise$=new Promise(n=>s.$onReadyResolve$=n),e["s-p"]=[],e["s-rc"]=[]),de(e,s,t.$listeners$),he.set(e,s)},Z=(e,t)=>t in e,A=(e,t)=>(0,console.error)(e,t),ge=$.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],st=(...e)=>console.error(...ge,...e),pe=(...e)=>console.warn(...ge,...e),B=new Map,nt=[],L=typeof window<"u"?window:{};$.cssVarShim&&L.CSS;const m=L.document||{head:{}},xt=L.HTMLElement||class{},h={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},U=$.shadowDomShim&&$.shadowDom?(()=>(m.head.attachShadow+"").indexOf("[native")>-1)():!0,ot=(()=>{let e=!1;try{m.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),lt=e=>Promise.resolve(e),rt=$.constructableCSS?(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})():!1,V=[],ye=[],it=(e,t)=>s=>{e.push(s),F||(F=!0,t&&h.$flags$&4?ct(j):h.raf(j))},ee=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){A(s)}e.length=0},j=()=>{ee(V),ee(ye),(F=V.length>0)&&h.raf(j)},ct=e=>lt().then(e),at=it(ye,!0);/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.0-beta.97
 */const $t="calcite-theme-auto",ft="calcite-theme-dark",ut="calcite-theme-light",Et={autoTheme:$t,darkTheme:ft,lightTheme:ut,rtl:"calcite--rtl"},Rt={loading:"Loading"};function At(e){return Array.isArray(e)?e:Array.from(e)}function Dt(e){const t="dir",s=`[${t}]`,n=dt(e,s);return n?n.getAttribute(t):"ltr"}function Ot(e,t,s){const n=`[${t}]`,o=e.closest(n);return o?o.getAttribute(t):s}function me(e){return e.getRootNode()}function Se(e){return e.host||null}function wt(e,{selector:t,id:s}){function n(o){if(!o)return null;o.assignedSlot&&(o=o.assignedSlot);const l=me(o),r=s?"getElementById"in l?l.getElementById(s):null:t?l.querySelector(t):null,i=Se(l);return r||(i?n(i):null)}return n(e)}function dt(e,t){function s(n){return n?n.closest(t)||s(Se(me(n))):null}return s(e)}function ht(e,t){return ve(e,t)}function ve(e,t){if(!e)return;const s=t(e);if(s!==void 0)return s;const{parentNode:n}=e;return ve(n instanceof ShadowRoot?n.host:n,t)}function Ct(e,t){return!!ht(t,s=>s===e?!0:void 0)}function gt(e){return typeof(e==null?void 0:e.setFocus)=="function"}async function Pt(e){if(e)return gt(e)?e.setFocus():e.focus()}const R=":not([slot])";function Bt(e,t,s){t&&!Array.isArray(t)&&typeof t!="string"&&(s=t,t=null);const n=t?Array.isArray(t)?t.map(o=>`[slot="${o}"]`).join(","):`[slot="${t}"]`:R;return s!=null&&s.all?pt(e,n,s):yt(e,n,s)}function ke(e,t){return e?Array.from(e.children||[]).filter(s=>s==null?void 0:s.matches(t)):[]}function pt(e,t,s){let n=t===R?ke(e,R):Array.from(e.querySelectorAll(t));n=s&&s.direct===!1?n:n.filter(l=>l.parentElement===e),n=s!=null&&s.matches?n.filter(l=>l==null?void 0:l.matches(s.matches)):n;const o=s==null?void 0:s.selector;return o?n.map(l=>Array.from(l.querySelectorAll(o))).reduce((l,r)=>[...l,...r],[]).filter(l=>!!l):n}function yt(e,t,s){let n=t===R?ke(e,R)[0]||null:e.querySelector(t);n=s&&s.direct===!1||(n==null?void 0:n.parentElement)===e?n:null,n=s!=null&&s.matches?n!=null&&n.matches(s.matches)?n:null:n;const o=s==null?void 0:s.selector;return o?n==null?void 0:n.querySelector(o):n}function Ut(e,t,s){if(typeof t=="string"&&t!=="")return t;if(t==="")return e[s]}function It(e){return Boolean(e).toString()}function Ft(e){return!!(e.isPrimary&&e.button===0)}export{mt as B,Et as C,Lt as F,xt as H,Rt as T,$t as a,xe as b,kt as c,ft as d,St as e,bt as f,Dt as g,ne as h,dt as i,Ft as j,Pt as k,Bt as l,Ot as m,At as n,Ut as o,Tt as p,wt as q,Ct as r,vt as s,It as t};
